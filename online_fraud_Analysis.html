<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.29">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="u2613621 Jayrup Nakawala">
<meta name="author" content="u2536809 Yogi Patel">
<meta name="author" content="u2509367 Parth Rathwa">
<meta name="dcterms.date" content="2025-05-02">

<title>Online Payment Fraud Detection</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="online_fraud_Analysis_files/libs/clipboard/clipboard.min.js"></script>
<script src="online_fraud_Analysis_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="online_fraud_Analysis_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="online_fraud_Analysis_files/libs/quarto-html/popper.min.js"></script>
<script src="online_fraud_Analysis_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="online_fraud_Analysis_files/libs/quarto-html/anchor.min.js"></script>
<link href="online_fraud_Analysis_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="online_fraud_Analysis_files/libs/quarto-html/quarto-syntax-highlighting-0815c480559380816a4d1ea211a47e91.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="online_fraud_Analysis_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="online_fraud_Analysis_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="online_fraud_Analysis_files/libs/bootstrap/bootstrap-6e5ff12f349f7d7ee99023e5a7f49be9.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">


</head>

<body class="quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#import-necessary-libraries-at-the-top" id="toc-import-necessary-libraries-at-the-top" class="nav-link active" data-scroll-target="#import-necessary-libraries-at-the-top">Import necessary libraries at the top</a></li>
  <li><a href="#introduction-5-marks" id="toc-introduction-5-marks" class="nav-link" data-scroll-target="#introduction-5-marks">Introduction (5 Marks)</a></li>
  <li><a href="#introduction-to-the-chosen-techniques-5-marks" id="toc-introduction-to-the-chosen-techniques-5-marks" class="nav-link" data-scroll-target="#introduction-to-the-chosen-techniques-5-marks">Introduction to the Chosen Techniques (5 Marks)</a></li>
  <li><a href="#introduction-of-the-dataset-5-marks" id="toc-introduction-of-the-dataset-5-marks" class="nav-link" data-scroll-target="#introduction-of-the-dataset-5-marks">Introduction of the Dataset (5 Marks)</a></li>
  </ul>
</nav>
</div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Online Payment Fraud Detection</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Authors</div>
    <div class="quarto-title-meta-contents">
             <p>u2613621 Jayrup Nakawala </p>
             <p>u2536809 Yogi Patel </p>
             <p>u2509367 Parth Rathwa </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">May 2, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="import-necessary-libraries-at-the-top" class="level2">
<h2 class="anchored" data-anchor-id="import-necessary-libraries-at-the-top">Import necessary libraries at the top</h2>
<div id="ef2eddf2" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.model_selection <span class="im">import</span> train_test_split</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.preprocessing <span class="im">import</span> OneHotEncoder</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.tree <span class="im">import</span> DecisionTreeClassifier, plot_tree</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.metrics <span class="im">import</span> confusion_matrix, classification_report, accuracy_score, precision_score, recall_score, f1_score</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> seaborn <span class="im">as</span> sns</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<ul>
<li><strong>Group Members:</strong> [Member 1 Name], [Member 2 Name], [Member 3 Name]</li>
<li><strong>Date:</strong> [Date of Submission]</li>
</ul>
</section>
<section id="introduction-5-marks" class="level2">
<h2 class="anchored" data-anchor-id="introduction-5-marks">Introduction (5 Marks)</h2>
<p>Online payment systems have become ubiquitous, facilitating transactions globally. However, this convenience comes with the significant risk of fraudulent activities. Detecting fraudulent transactions is crucial for financial institutions and e-commerce platforms to minimize losses and maintain customer trust. Machine learning techniques offer powerful tools for identifying complex patterns indicative of fraud that traditional rule-based systems might miss.</p>
<p>This notebook implements a Decision Tree classifier to predict fraudulent online payment transactions. We will use a publicly available dataset containing anonymized transaction data. The goal is to build a model that can effectively distinguish between legitimate and fraudulent transactions based on the provided features, leveraging the principles of decision tree induction discussed in the course lectures (Weeks 8 &amp; 9).</p>
</section>
<section id="introduction-to-the-chosen-techniques-5-marks" class="level2">
<h2 class="anchored" data-anchor-id="introduction-to-the-chosen-techniques-5-marks">Introduction to the Chosen Techniques (5 Marks)</h2>
<p><strong>Decision Trees:</strong> As discussed in Week 8, a Decision Tree is a supervised machine learning algorithm used for both classification and regression tasks. It operates by recursively partitioning the data based on the values of input features. The structure resembles a flowchart: * <strong>Root Node:</strong> Represents the entire dataset. * <strong>Internal Nodes:</strong> Represent tests on specific attributes (features). * <strong>Branches:</strong> Represent the outcome of a test (e.g., ‘amount &lt; 1000’). * <strong>Leaf Nodes (Terminal Nodes):</strong> Represent the final classification (or prediction) for instances that reach that node (e.g., ‘Fraud’, ‘Not Fraud’).</p>
<p><strong>How it Works (Induction):</strong> Decision trees are typically built using a greedy, top-down approach (like ID3 or C4.5/J48 mentioned in Week 8 &amp; 9 slides). At each node, the algorithm selects the “best” attribute to split the data based on a specific criterion. Common criteria aim to maximize the purity of the resulting child nodes: 1. <strong>Information Gain (Used by ID3):</strong> Measures the reduction in entropy (uncertainty) achieved by splitting on an attribute. It favors attributes with many distinct values (Week 8, Slide 10-13; Week 9, Slide 2). 2. <strong>Gain Ratio (Used by C4.5/J48):</strong> A modification of Information Gain that penalizes attributes with many values by normalizing using “Split Information” (Week 9, Slides 3-5). 3. <strong>Gini Impurity:</strong> Measures the probability of misclassifying a randomly chosen element if it were randomly labeled according to the distribution of labels in the subset. Scikit-learn’s default criterion is Gini.</p>
<p><strong>Advantages:</strong> * Simple to understand and interpret. The tree structure can be visualized. * Requires relatively little data preparation (e.g., handles non-linear relationships, no need for feature scaling). * Can handle both numerical and categorical data (though scikit-learn requires encoding).</p>
<p><strong>Disadvantages:</strong> * Prone to overfitting, especially with deep trees (Week 9, Slide 7). Techniques like pruning (pre-pruning or post-pruning) or setting <code>max_depth</code> are used to mitigate this. * Can be unstable; small variations in data can result in a different tree. * Can create biased trees if some classes dominate.</p>
<p><strong>Evaluation Metrics:</strong> For classification tasks, especially potentially imbalanced ones like fraud detection, we use metrics like: * <strong>Confusion Matrix:</strong> Shows True Positives (TP), True Negatives (TN), False Positives (FP), False Negatives (FN). * <strong>Accuracy:</strong> (TP+TN)/Total. Can be misleading if data is imbalanced. * <strong>Precision:</strong> TP/(TP+FP). Measures the accuracy of positive predictions (minimize false alarms). * <strong>Recall (Sensitivity):</strong> TP/(TP+FN). Measures how many actual positives were correctly identified (minimize missed frauds). * <strong>F1-Score:</strong> Harmonic mean of Precision and Recall.</p>
</section>
<section id="introduction-of-the-dataset-5-marks" class="level2">
<h2 class="anchored" data-anchor-id="introduction-of-the-dataset-5-marks">Introduction of the Dataset (5 Marks)</h2>
<p>The dataset used for this task is the “Online Payments Fraud Detection” dataset sourced from Kaggle. Link: https://www.kaggle.com/datasets/jainilcoder/online-payment-fraud-detection</p>
<p>Loading the Data:</p>
<div id="624e4268" class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co"># --- Code Cell ---</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>file_path <span class="op">=</span> <span class="st">'onlinefraud.csv'</span> <span class="co"># Make sure this file is in the same directory or provide the full path</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.read_csv(file_path)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Display first few rows</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Dataset Head:"</span>)</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(df.head())</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Display dataset information (columns, types, non-null counts)</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Dataset Info:"</span>)</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>df.info()</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Display basic statistics for numerical columns</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Dataset Description:"</span>)</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(df.describe())</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a><span class="co"># Check for missing values</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Missing Values per Column:"</span>)</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(df.isnull().<span class="bu">sum</span>())</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Dataset Head:
   step      type    amount     nameOrig  oldbalanceOrg  newbalanceOrig  \
0     1   PAYMENT   9839.64  C1231006815       170136.0       160296.36   
1     1   PAYMENT   1864.28  C1666544295        21249.0        19384.72   
2     1  TRANSFER    181.00  C1305486145          181.0            0.00   
3     1  CASH_OUT    181.00   C840083671          181.0            0.00   
4     1   PAYMENT  11668.14  C2048537720        41554.0        29885.86   

      nameDest  oldbalanceDest  newbalanceDest  isFraud  isFlaggedFraud  
0  M1979787155             0.0             0.0        0               0  
1  M2044282225             0.0             0.0        0               0  
2   C553264065             0.0             0.0        1               0  
3    C38997010         21182.0             0.0        1               0  
4  M1230701703             0.0             0.0        0               0  

Dataset Info:
&lt;class 'pandas.core.frame.DataFrame'&gt;
RangeIndex: 6362620 entries, 0 to 6362619
Data columns (total 11 columns):
 #   Column          Dtype  
---  ------          -----  
 0   step            int64  
 1   type            object 
 2   amount          float64
 3   nameOrig        object 
 4   oldbalanceOrg   float64
 5   newbalanceOrig  float64
 6   nameDest        object 
 7   oldbalanceDest  float64
 8   newbalanceDest  float64
 9   isFraud         int64  
 10  isFlaggedFraud  int64  
dtypes: float64(5), int64(3), object(3)
memory usage: 534.0+ MB

Dataset Description:
               step        amount  oldbalanceOrg  newbalanceOrig  \
count  6.362620e+06  6.362620e+06   6.362620e+06    6.362620e+06   
mean   2.433972e+02  1.798619e+05   8.338831e+05    8.551137e+05   
std    1.423320e+02  6.038582e+05   2.888243e+06    2.924049e+06   
min    1.000000e+00  0.000000e+00   0.000000e+00    0.000000e+00   
25%    1.560000e+02  1.338957e+04   0.000000e+00    0.000000e+00   
50%    2.390000e+02  7.487194e+04   1.420800e+04    0.000000e+00   
75%    3.350000e+02  2.087215e+05   1.073152e+05    1.442584e+05   
max    7.430000e+02  9.244552e+07   5.958504e+07    4.958504e+07   

       oldbalanceDest  newbalanceDest       isFraud  isFlaggedFraud  
count    6.362620e+06    6.362620e+06  6.362620e+06    6.362620e+06  
mean     1.100702e+06    1.224996e+06  1.290820e-03    2.514687e-06  
std      3.399180e+06    3.674129e+06  3.590480e-02    1.585775e-03  
min      0.000000e+00    0.000000e+00  0.000000e+00    0.000000e+00  
25%      0.000000e+00    0.000000e+00  0.000000e+00    0.000000e+00  
50%      1.327057e+05    2.146614e+05  0.000000e+00    0.000000e+00  
75%      9.430367e+05    1.111909e+06  0.000000e+00    0.000000e+00  
max      3.560159e+08    3.561793e+08  1.000000e+00    1.000000e+00  

Missing Values per Column:
step              0
type              0
amount            0
nameOrig          0
oldbalanceOrg     0
newbalanceOrig    0
nameDest          0
oldbalanceDest    0
newbalanceDest    0
isFraud           0
isFlaggedFraud    0
dtype: int64</code></pre>
</div>
</div>
<p><strong>Dataset Columns and Description:</strong> As provided in the prompt and observed from <code>df.info()</code> and <code>df.describe()</code>: * <code>step</code>: Time unit (1 step = 1 hour). Numerical. * <code>type</code>: Type of transaction (e.g., PAYMENT, TRANSFER, CASH_OUT). Categorical (Object type). * <code>amount</code>: Transaction amount. Numerical (Float). * <code>nameOrig</code>: Customer initiating the transaction. Categorical (Object type) - High Cardinality. * <code>oldbalanceOrg</code>: Origin account balance before the transaction. Numerical (Float). * <code>newbalanceOrig</code>: Origin account balance after the transaction. Numerical (Float). * <code>nameDest</code>: Customer receiving the transaction. Categorical (Object type) - High Cardinality. * <code>oldbalanceDest</code>: Destination account balance before the transaction. Numerical (Float). * <code>newbalanceDest</code>: Destination account balance after the transaction. Numerical (Float). * <code>isFraud</code>: Target variable. 1 if the transaction is fraudulent, 0 otherwise. Numerical (Integer). * <code>isFlaggedFraud</code>: System flag based on a business rule (transfer over 200k). Numerical (Integer).</p>
<p><strong>Target Variable Distribution:</strong> Fraud datasets are often highly imbalanced. Let’s check the distribution of <code>isFraud</code>.</p>
<div id="535a7bcc" class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Target Variable (isFraud) Distribution:"</span>)</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(df[<span class="st">'isFraud'</span>].value_counts())</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Fraud Percentage:"</span>)</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>fraud_percentage <span class="op">=</span> (df[<span class="st">'isFraud'</span>].<span class="bu">sum</span>() <span class="op">/</span> <span class="bu">len</span>(df)) <span class="op">*</span> <span class="dv">100</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="sc">{</span>fraud_percentage<span class="sc">:.4f}</span><span class="ss">%"</span>)</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Visualize the distribution</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>sns.countplot(x<span class="op">=</span><span class="st">'isFraud'</span>, data<span class="op">=</span>df)</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Distribution of Fraudulent vs Non-Fraudulent Transactions'</span>)</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
Target Variable (isFraud) Distribution:
isFraud
0    6354407
1       8213
Name: count, dtype: int64

Fraud Percentage:
0.1291%</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="online_fraud_Analysis_files/figure-html/cell-4-output-2.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p><strong>Initial Observations:</strong> * The dataset is large (over 6 million entries). * There are no missing values. * The <code>isFraud</code> column confirms this is a binary classification task. * The dataset is highly imbalanced, with only a very small percentage of transactions being fraudulent. This means accuracy alone is not a sufficient evaluation metric; we must focus on Precision and Recall.</p>
<p>— Markdown Cell — ## Input Encoding / Input Representation (How and why?) (5 Marks)</p>
<p><strong>Need for Encoding:</strong> Decision Tree algorithms implemented in libraries like scikit-learn require all input features to be numerical. Our dataset contains categorical features (<code>type</code>, <code>nameOrig</code>, <code>nameDest</code>) that need to be converted.</p>
<p><strong>Handling Categorical Features:</strong> 1. <strong><code>type</code>:</strong> This feature has a small number of distinct categories (e.g., ‘CASH_OUT’, ‘PAYMENT’, ‘CASH_IN’, ‘TRANSFER’, ‘DEBIT’). Since there’s no inherent order between these types, <strong>One-Hot Encoding</strong> is the appropriate method. It creates new binary (0/1) columns for each category, preventing the model from assuming any ordinal relationship. 2. <strong><code>nameOrig</code>, <code>nameDest</code>:</strong> These are customer/account identifiers. They have very high cardinality (many unique values). Including them directly via one-hot encoding would create millions of sparse features, making the model computationally expensive and likely leading to overfitting. Simple label encoding would incorrectly imply an order. Therefore, these features are generally not useful in their raw form for tree-based models and <strong>will be dropped</strong>. More advanced feature engineering (e.g., transaction frequency per user) could potentially extract value, but is beyond the scope of this basic implementation.</p>
<p><strong>Handling Other Features:</strong> * <strong><code>step</code>:</strong> While numerical, the absolute time step might not be as relevant as time-based patterns (e.g., time of day, day of week). For simplicity, we will <strong>keep it</strong> as is for this baseline model, but acknowledge potential for feature engineering. * <strong><code>isFlaggedFraud</code>:</strong> This is a rule-based flag from the system. While potentially predictive, it might be <em>too</em> predictive or represent information leakage if the flag is set <em>based on</em> knowing it’s likely fraud, potentially overlapping with our target. Furthermore, the description suggests it’s based on a simple rule (transfer &gt; 200k), which the tree can learn itself from <code>amount</code> and <code>type</code>. To build a model based on the core transaction features, we will <strong>drop <code>isFlaggedFraud</code></strong>. * <strong>Numerical Features:</strong> <code>amount</code>, <code>oldbalanceOrg</code>, <code>newbalanceOrig</code>, <code>oldbalanceDest</code>, <code>newbalanceDest</code> are already numerical and can be used directly. Decision trees do not strictly require scaling, so we will use them as is.</p>
<p><strong>Defining Features (X) and Target (y):</strong> * <strong>Target (y):</strong> <code>isFraud</code> * <strong>Features (X):</strong> <code>step</code>, <code>amount</code>, <code>oldbalanceOrg</code>, <code>newbalanceOrig</code>, <code>oldbalanceDest</code>, <code>newbalanceDest</code>, and the one-hot encoded columns derived from <code>type</code>.</p>
<div id="9b1bd4c5" class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co"># --- Code Cell ---</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Drop irrelevant/high-cardinality columns</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>df_processed <span class="op">=</span> df.drop([<span class="st">'nameOrig'</span>, <span class="st">'nameDest'</span>, <span class="st">'isFlaggedFraud'</span>], axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Columns after dropping irrelevant ones:"</span>, df_processed.columns)</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Apply One-Hot Encoding to 'type'</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>encoder <span class="op">=</span> OneHotEncoder(sparse_output<span class="op">=</span><span class="va">False</span>, drop<span class="op">=</span><span class="st">'first'</span>) <span class="co"># drop='first' to avoid multicollinearity</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>type_encoded <span class="op">=</span> encoder.fit_transform(df_processed[[<span class="st">'type'</span>]])</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a DataFrame with the encoded columns</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Use feature names provided by the encoder</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>type_encoded_df <span class="op">=</span> pd.DataFrame(type_encoded, columns<span class="op">=</span>encoder.get_feature_names_out([<span class="st">'type'</span>]))</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Drop the original 'type' column and concatenate the encoded ones</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>df_processed <span class="op">=</span> df_processed.drop(<span class="st">'type'</span>, axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>df_final <span class="op">=</span> pd.concat([df_processed, type_encoded_df], axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Final DataFrame Head after Encoding:"</span>)</span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(df_final.head())</span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Final DataFrame Columns:"</span>, df_final.columns)</span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a><span class="co"># Define Features (X) and Target (y)</span></span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> df_final.drop(<span class="st">'isFraud'</span>, axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> df_final[<span class="st">'isFraud'</span>]</span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Shape of Features (X):"</span>, X.shape)</span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Shape of Target (y):"</span>, y.shape)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Columns after dropping irrelevant ones: Index(['step', 'type', 'amount', 'oldbalanceOrg', 'newbalanceOrig',
       'oldbalanceDest', 'newbalanceDest', 'isFraud'],
      dtype='object')

Final DataFrame Head after Encoding:
   step    amount  oldbalanceOrg  newbalanceOrig  oldbalanceDest  \
0     1   9839.64       170136.0       160296.36             0.0   
1     1   1864.28        21249.0        19384.72             0.0   
2     1    181.00          181.0            0.00             0.0   
3     1    181.00          181.0            0.00         21182.0   
4     1  11668.14        41554.0        29885.86             0.0   

   newbalanceDest  isFraud  type_CASH_OUT  type_DEBIT  type_PAYMENT  \
0             0.0        0            0.0         0.0           1.0   
1             0.0        0            0.0         0.0           1.0   
2             0.0        1            0.0         0.0           0.0   
3             0.0        1            1.0         0.0           0.0   
4             0.0        0            0.0         0.0           1.0   

   type_TRANSFER  
0            0.0  
1            0.0  
2            1.0  
3            0.0  
4            0.0  

Final DataFrame Columns: Index(['step', 'amount', 'oldbalanceOrg', 'newbalanceOrig', 'oldbalanceDest',
       'newbalanceDest', 'isFraud', 'type_CASH_OUT', 'type_DEBIT',
       'type_PAYMENT', 'type_TRANSFER'],
      dtype='object')

Shape of Features (X): (6362620, 10)
Shape of Target (y): (6362620,)</code></pre>
</div>
</div>
<p>— Markdown Cell — ## Coding for the Implementation with Comments (10 marks)</p>
<p>Now we will implement the Decision Tree model using scikit-learn.</p>
<div id="e91ea436" class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co"># --- Code Cell ---</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="co"># 1. Split Data into Training and Testing Sets</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="co"># We use train_test_split to divide the data.</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="co"># test_size=0.2 means 20% of the data is reserved for testing.</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="co"># random_state ensures reproducibility of the split.</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a><span class="co"># stratify=y is crucial for imbalanced datasets; it ensures that the proportion</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a><span class="co"># of fraud/non-fraud instances is the same in both train and test sets.</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>X_train, X_test, y_train, y_test <span class="op">=</span> train_test_split(X, y, test_size<span class="op">=</span><span class="fl">0.2</span>, random_state<span class="op">=</span><span class="dv">42</span>, stratify<span class="op">=</span>y)</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Training set shape:"</span>, X_train.shape, y_train.shape)</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Testing set shape:"</span>, X_test.shape, y_test.shape)</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Fraud distribution in Training set:"</span>)</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(y_train.value_counts(normalize<span class="op">=</span><span class="va">True</span>))</span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Fraud distribution in Testing set:"</span>)</span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(y_test.value_counts(normalize<span class="op">=</span><span class="va">True</span>))</span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a><span class="co"># 2. Instantiate the Decision Tree Classifier</span></span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a><span class="co"># We create an instance of the DecisionTreeClassifier.</span></span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a><span class="co"># criterion='gini' uses the Gini impurity for splitting (default). Could use 'entropy' for Information Gain.</span></span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a><span class="co"># max_depth=10 is set as a pre-pruning measure to prevent the tree from growing too deep and overfitting.</span></span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a><span class="co"># This value can be tuned. Without it, the tree might grow very large on this dataset.</span></span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a><span class="co"># random_state ensures reproducibility of the model training process.</span></span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a>dt_classifier <span class="op">=</span> DecisionTreeClassifier(criterion<span class="op">=</span><span class="st">'gini'</span>, max_depth<span class="op">=</span><span class="dv">10</span>, random_state<span class="op">=</span><span class="dv">42</span>)</span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-28"><a href="#cb8-28" aria-hidden="true" tabindex="-1"></a><span class="co"># 3. Train the Model</span></span>
<span id="cb8-29"><a href="#cb8-29" aria-hidden="true" tabindex="-1"></a><span class="co"># We fit the classifier to the training data (X_train, y_train).</span></span>
<span id="cb8-30"><a href="#cb8-30" aria-hidden="true" tabindex="-1"></a><span class="co"># The model learns the patterns linking features to the 'isFraud' target.</span></span>
<span id="cb8-31"><a href="#cb8-31" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Training the Decision Tree model..."</span>)</span>
<span id="cb8-32"><a href="#cb8-32" aria-hidden="true" tabindex="-1"></a>dt_classifier.fit(X_train, y_train)</span>
<span id="cb8-33"><a href="#cb8-33" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Model training finished."</span>)</span>
<span id="cb8-34"><a href="#cb8-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-35"><a href="#cb8-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-36"><a href="#cb8-36" aria-hidden="true" tabindex="-1"></a><span class="co"># 4. Make Predictions</span></span>
<span id="cb8-37"><a href="#cb8-37" aria-hidden="true" tabindex="-1"></a><span class="co"># We use the trained model to predict the 'isFraud' status for the unseen test data (X_test).</span></span>
<span id="cb8-38"><a href="#cb8-38" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Making predictions on the test set..."</span>)</span>
<span id="cb8-39"><a href="#cb8-39" aria-hidden="true" tabindex="-1"></a>y_pred <span class="op">=</span> dt_classifier.predict(X_test)</span>
<span id="cb8-40"><a href="#cb8-40" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Predictions finished."</span>)</span>
<span id="cb8-41"><a href="#cb8-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-42"><a href="#cb8-42" aria-hidden="true" tabindex="-1"></a><span class="co"># (Optional) Predict probabilities - useful for ROC curves, etc.</span></span>
<span id="cb8-43"><a href="#cb8-43" aria-hidden="true" tabindex="-1"></a><span class="co"># y_pred_proba = dt_classifier.predict_proba(X_test)[:, 1]</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Training set shape: (5090096, 10) (5090096,)
Testing set shape: (1272524, 10) (1272524,)

Fraud distribution in Training set:
isFraud
0    0.998709
1    0.001291
Name: proportion, dtype: float64

Fraud distribution in Testing set:
isFraud
0    0.998709
1    0.001291
Name: proportion, dtype: float64

Training the Decision Tree model...
Model training finished.

Making predictions on the test set...
Predictions finished.</code></pre>
</div>
</div>
<p>— Markdown Cell — ## Analysis of Results and Comments (10marks)</p>
<p>We now evaluate the performance of our trained Decision Tree model on the test set using the standard classification metrics.</p>
<div id="86bf30d0" class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co"># --- Code Cell ---</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="co"># 1. Calculate Evaluation Metrics</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>accuracy <span class="op">=</span> accuracy_score(y_test, y_pred)</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>precision <span class="op">=</span> precision_score(y_test, y_pred) <span class="co"># Focus on class 1 (Fraud)</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>recall <span class="op">=</span> recall_score(y_test, y_pred)       <span class="co"># Focus on class 1 (Fraud)</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>f1 <span class="op">=</span> f1_score(y_test, y_pred)               <span class="co"># Focus on class 1 (Fraud)</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>conf_matrix <span class="op">=</span> confusion_matrix(y_test, y_pred)</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>class_report <span class="op">=</span> classification_report(y_test, y_pred, target_names<span class="op">=</span>[<span class="st">'Not Fraud (0)'</span>, <span class="st">'Fraud (1)'</span>])</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">--- Model Evaluation Results ---"</span>)</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Accuracy: </span><span class="sc">{</span>accuracy<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Precision (Fraud): </span><span class="sc">{</span>precision<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Recall (Fraud): </span><span class="sc">{</span>recall<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"F1-Score (Fraud): </span><span class="sc">{</span>f1<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Confusion Matrix:"</span>)</span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a><span class="co"># Displaying Confusion Matrix more visually</span></span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">6</span>, <span class="dv">4</span>))</span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>sns.heatmap(conf_matrix, annot<span class="op">=</span><span class="va">True</span>, fmt<span class="op">=</span><span class="st">'d'</span>, cmap<span class="op">=</span><span class="st">'Blues'</span>,</span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a>            xticklabels<span class="op">=</span>[<span class="st">'Predicted Not Fraud'</span>, <span class="st">'Predicted Fraud'</span>],</span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a>            yticklabels<span class="op">=</span>[<span class="st">'Actual Not Fraud'</span>, <span class="st">'Actual Fraud'</span>])</span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'Actual'</span>)</span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'Predicted'</span>)</span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Confusion Matrix'</span>)</span>
<span id="cb10-26"><a href="#cb10-26" aria-hidden="true" tabindex="-1"></a>plt.show()</span>
<span id="cb10-27"><a href="#cb10-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-28"><a href="#cb10-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-29"><a href="#cb10-29" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Classification Report:"</span>)</span>
<span id="cb10-30"><a href="#cb10-30" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(class_report)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
--- Model Evaluation Results ---
Accuracy: 0.9996
Precision (Fraud): 0.9581
Recall (Fraud): 0.7517
F1-Score (Fraud): 0.8424

Confusion Matrix:</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="online_fraud_Analysis_files/figure-html/cell-7-output-2.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>
Classification Report:
               precision    recall  f1-score   support

Not Fraud (0)       1.00      1.00      1.00   1270881
    Fraud (1)       0.96      0.75      0.84      1643

     accuracy                           1.00   1272524
    macro avg       0.98      0.88      0.92   1272524
 weighted avg       1.00      1.00      1.00   1272524
</code></pre>
</div>
</div>
<div id="fe95c365" class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">40</span>,<span class="dv">20</span>))</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="co"># only show depth till 5</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>plot_tree(dt_classifier, feature_names<span class="op">=</span>X.columns, class_names<span class="op">=</span>[<span class="st">'Not Fraud'</span>, <span class="st">'Fraud'</span>], filled<span class="op">=</span><span class="va">True</span>, max_depth<span class="op">=</span><span class="dv">5</span>)</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="online_fraud_Analysis_files/figure-html/cell-8-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p><strong>Comments on Results:</strong></p>
<ul>
<li><strong>Accuracy:</strong> The overall accuracy is typically very high (likely &gt; 99%) due to the severe class imbalance. However, this metric is misleading as a model predicting “Not Fraud” for every transaction would achieve high accuracy but be useless.</li>
<li><strong>Confusion Matrix Breakdown:</strong>
<ul>
<li><strong>True Negatives (TN):</strong> Top-left. Correctly identified non-fraudulent transactions (usually a very large number).</li>
<li><strong>False Positives (FP):</strong> Top-right. Legitimate transactions incorrectly flagged as fraud (Type I error). Aim to minimize for customer satisfaction.</li>
<li><strong>False Negatives (FN):</strong> Bottom-left. Fraudulent transactions missed by the model (Type II error). Critical to minimize for loss prevention.</li>
<li><strong>True Positives (TP):</strong> Bottom-right. Correctly identified fraudulent transactions.</li>
</ul></li>
<li><strong>Precision (Fraud):</strong> This tells us “Out of all transactions predicted as fraud, what proportion actually <em>were</em> fraud?”. A high precision means fewer false alarms (low FP rate). The result here might be high (e.g., &gt; 0.8 or 0.9) indicating the model is quite confident when it flags fraud.</li>
<li><strong>Recall (Fraud):</strong> This tells us “Out of all actual fraud transactions, what proportion did the model <em>catch</em>?”. This is often the most critical metric in fraud detection. A recall of, say, 0.75 means the model caught 75% of actual frauds, but missed 25% (high FN rate). Improving recall is often a primary goal, even if it slightly lowers precision.</li>
<li><strong>F1-Score (Fraud):</strong> Provides a balance between precision and recall. Useful for overall model assessment for the minority class.</li>
<li><strong>Classification Report:</strong> Summarizes precision, recall, and F1-score for both classes (0 and 1) and provides averages. We primarily focus on the metrics for the ‘Fraud (1)’ class.</li>
</ul>
<p><strong>Overall Assessment:</strong> The Decision Tree model (with <code>max_depth=10</code>) likely achieves reasonable performance, especially in precision. Precision might be high (e.g., 90%+), meaning when it predicts fraud, it’s often correct. However, Recall might be lower (e.g., 70-85%), indicating that it misses a portion of the fraudulent transactions. The performance heavily depends on the chosen <code>max_depth</code> and other potential tuning. Without limiting depth, the tree might achieve higher recall on the training set but perform poorly on the test set due to overfitting.</p>
<p><strong>Potential Improvements:</strong> 1. <strong>Hyperparameter Tuning:</strong> Use techniques like GridSearchCV or RandomizedSearchCV to find optimal values for <code>max_depth</code>, <code>min_samples_split</code>, <code>min_samples_leaf</code>, and <code>criterion</code> (‘gini’ vs ‘entropy’). 2. <strong>Handling Imbalance:</strong> Implement techniques specifically designed for imbalanced data: * <strong>Class Weighting:</strong> Assign a higher penalty to misclassifying the minority class (fraud) during training (<code>class_weight='balanced'</code> in <code>DecisionTreeClassifier</code>). * <strong>Resampling:</strong> Oversample the minority class (e.g., SMOTE) or undersample the majority class in the <em>training data only</em>. 3. <strong>Feature Engineering:</strong> Create new features that might be more predictive, such as: * Difference between old and new balances (<code>delta_balance_orig</code>, <code>delta_balance_dest</code>). * Ratios of amount to balances. * Features based on <code>step</code> (e.g., hour of day, day of week). 4. <strong>Ensemble Methods:</strong> Use more robust algorithms often built on decision trees, like Random Forests or Gradient Boosting (e.g., XGBoost, LightGBM), which usually offer better performance and are less prone to overfitting. 5. <strong>Pruning:</strong> Explore post-pruning techniques if a deeper tree is initially grown.</p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>